name: CI Pipeline

on: push

jobs:
  project-testing:
    runs-on: ubuntu-latest

    steps:
      - name: checkout code
        uses: actions/checkout@v3

      - name: setup python
        uses: actions/setup-python@v2
        with:
          python-version: '3.10'

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: install dependencies
        run: |
          pip install -r requirements.txt

      - name: run pipeline
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
        run: |
          dvc repro

      - name: Run Data quality test
        if: success()
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
        run: |
          python -m unittest tests/test_data_quality.py

      - name: Run model test
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
        run: |
          python -m unittest tests/test_model_validation.py

      # - name: Start Flask API (background)
      #   env:
      #     CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
      #     # optional: expose MLflow/DAGSHUB secrets if needed
      #     # MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
      #     # DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}
      #   run: |
      #     echo "Starting Flask app in background..."
      #     # -u unbuffered so logs flush immediately; nohup keeps it alive in background
      #     nohup python -u flask_app/app.py > flask.log 2>&1 &
      #     echo $! > flask.pid
      #     echo "Flask PID: $(cat flask.pid)"

      #     echo "Waiting for /health (timeout: 60s)..."
      #     for i in {1..60}; do
      #       if curl -sSf http://localhost:5000/health > /dev/null 2>&1; then
      #         echo "Flask health OK"
      #         break
      #       fi
      #       sleep 1
      #     done

      #     # final check
      #     if ! curl -sSf http://localhost:5000/health > /dev/null 2>&1; then
      #       echo "ERROR: Flask did not become healthy within timeout. Dumping last 200 lines of flask.log:"
      #       tail -n 200 flask.log || true
      #       # fail the job here so we don't run tests against nothing
      #       exit 1
      #     fi
      #   shell: bash    

      - name: Start Flask App
        run: |
          export FLASK_APP=app.py  # Adjust if needed
          flask run --host=0.0.0.0 --port=5000 &
          sleep 5  # Wait for startup
      
      - name: Run Flask app test
        if: success()
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
        run: |
          python -m unittest tests/test_flask_app.py

      - name: Stop Flask API (always run)
        if: always()
        run: |
          echo "Stopping Flask..."
          # kill by stored PID (preferred)
          if [ -f flask.pid ]; then
            kill $(cat flask.pid) || true
            rm -f flask.pid
          fi
          # fallback: kill any lingering process by file pattern (harmless if nothing found)
          pkill -f "flask_app/app.py" || true
          echo "Flask stopped (or no process found)."
          echo "---- flask.log (last 200 lines) ----"
          tail -n 200 flask.log || true
        shell: bash    